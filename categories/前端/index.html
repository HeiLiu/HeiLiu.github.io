<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>分类：前端 - HeiLiu</title>
    <meta charset="UTF-8">
    <meta name="description" content="一直在路上的程序员">
    <meta name="keywords" content="博客 程序员 分享">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    
    

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <meta name="description" content="一直在路上的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="HeiLiu">
<meta property="og:url" content="https://heiliu.github.io/categories/%E5%89%8D%E7%AB%AF/">
<meta property="og:site_name" content="HeiLiu">
<meta property="og:description" content="一直在路上的程序员">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="小别致真东西">
<meta property="article:tag" content="博客 程序员 分享">
<meta name="twitter:card" content="summary">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/npm/highlight.js@9.15.8/styles/atom-one-dark.css,npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css,gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css,npm/hexo-theme-nexmoe@latest/source/lib/mdui_043tiny/css/mdui.css,npm/hexo-theme-nexmoe@latest/source/lib/iconfont/iconfont.css?v=233" crossorigin>
    <link rel="stylesheet" href="/css/style.css?v=1630501965045">
    
    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1630501965045">
<meta name="generator" content="Hexo 5.4.0"></head>

<body class="mdui-drawer-body-left">
    
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="小别致真东西" class="mdui-btn mdui-btn-icon"><img src="https://avatars1.githubusercontent.com/u/29034936?s=400&amp;u=568e2bb8e4bb03a573e9138e715699e492fbe399&amp;v=4" alt="小别致真东西"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="小别致真东西">
            <img src="https://avatars1.githubusercontent.com/u/29034936?s=400&amp;u=568e2bb8e4bb03a573e9138e715699e492fbe399&amp;v=4" alt="小别致真东西" alt="小别致真东西">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>77</div>
        <div><span>标签</span>31</div>
        <div><span>分类</span>26</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive/" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/about/" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
         
            <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
                <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
            </form>
         
    </div>
</div>
    
    <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://github.com/heiliu/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a><a class="mdui-ripple" href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=969403750&website=www.oicqzone.com" target="_blank" mdui-tooltip="{content: 'QQ'}" style="color: rgb(249, 174, 8);background-color: rgba(249, 174, 8, .1);">
            <i class="nexmoefont icon-QQ"></i>
        </a>
    </div>
</div>
    
    
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/Css/" style="font-size: 12.5px;">Css</a> <a href="/tags/Css3/" style="font-size: 10px;">Css3</a> <a href="/tags/E2E%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">E2E测试</a> <a href="/tags/Flex/" style="font-size: 10px;">Flex</a> <a href="/tags/Foo/" style="font-size: 10px;">Foo</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/NPM/" style="font-size: 10px;">NPM</a> <a href="/tags/Note/" style="font-size: 15px;">Note</a> <a href="/tags/Quote/" style="font-size: 10px;">Quote</a> <a href="/tags/React/" style="font-size: 17.5px;">React</a> <a href="/tags/React-router/" style="font-size: 10px;">React-router</a> <a href="/tags/Skill/" style="font-size: 10px;">Skill</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/WebPack/" style="font-size: 10px;">WebPack</a> <a href="/tags/Yarn/" style="font-size: 10px;">Yarn</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/redux/" style="font-size: 10px;">redux</a> <a href="/tags/%E5%80%92%E8%85%BE/" style="font-size: 12.5px;">倒腾</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 17.5px;">前端</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 12.5px;">小程序</a> <a href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" style="font-size: 10px;">性能优化</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">笔记</a> <a href="/tags/%E8%A7%84%E5%88%92/" style="font-size: 10px;">规划</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 12.5px;">面试</a> <a href="/tags/%F0%9F%8C%9D/" style="font-size: 12.5px;">🌝</a>
    </div>
    
  </div>

    
    
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Skill/Git/">Git</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/JS语言精粹/">JS语言精粹</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Skill/JavaScript/">JavaScript</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/NPM/">NPM</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Node最佳实践/">Node最佳实践</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Skill/Note/">Note</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/React/">React</a>
          <span class="category-list-count">5</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Skill/">Skill</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/Test/">Test</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/前端/Vue/">Vue</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/hexo/">hexo</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/前端/webPack/">webPack</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/倒腾/">倒腾</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/前端/">前端</a>
          <span class="category-list-count">16</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/小程序/">小程序</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/有感/">有感</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/生活/">生活</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/笔记/">笔记</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/面试/">面试</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2021 小别致真东西
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2021/08/31/BFC/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="BFC 浅谈" class="lazyload">
                    <h1>BFC 浅谈</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年08月31日</a>
            <a><i class="nexmoefont icon-areachart"></i>1k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><hr>
<blockquote>
<p>Block formatting context （块级格式化上下文）  </p>
</blockquote>
<p>页面文档由块<code>block</code>构成 每个<code>block</code>在页面上占据自己的位置<br>使用新的元素构建BFC overflow：hidden | auto | scroll； 只要不为<code>visible </code>新的空间<br>告诉浏览器，外面的环境影响不到我了 我重新来进行Block formatting 布局和定位  </p>
<p><strong>核心：</strong><br>    新的BFC，给出了新的不受外界影响的块级格式化环境<br>    block 块级-&gt; 页面的基础<br>    formatting context 格式化-&gt; 渲染</p>
<h3 id="浏览器构建文档树的时候-布局和定位元素"><a href="#浏览器构建文档树的时候-布局和定位元素" class="headerlink" title="浏览器构建文档树的时候 布局和定位元素"></a>浏览器构建文档树的时候 布局和定位元素</h3><p>网页的定位（大） 文档流正常，浮动，定位，flex，table<br>广义的定位 块级元素的定位 垂直的定位；行内元素 左右定位 通过内容来确定<br>狭义的定位：<br>float 浮动元素，在一行的开始或者结束<br>flex 弹性布局<br>position</p>
<p>BFC 在正常的文档流里面重建一个新的上下文环境  </p>
<h3 id="BFC的约束规则"><a href="#BFC的约束规则" class="headerlink" title="BFC的约束规则"></a>BFC的约束规则</h3><ul>
<li><p>一、在浏览器进行页面元素布局的时候 同一个BFC的两个相邻的Box的margin 会重叠，与方向无关  </p>
<blockquote>
<p>破坏规则 创建新的BFC Context上下文的概念   </p>
</blockquote>
<p>  如何创建BFC？=&gt;重新规划一个（独立）渲染区域</p>
<ul>
<li>根元素body，天然是一个BFC    </li>
<li>overflow:hidden;  </li>
<li>float 不为none  </li>
<li>display:inline-block | table-cell |table-caption  </li>
<li>position:absolute | fixed 只要不为static  <blockquote>
<p>好像只剩块级元素和行内元素不是BFC</p>
</blockquote>
</li>
</ul>
</li>
<li><p>二、<code>BFC</code>的高度，浮动元素也要参与计算  </p>
<blockquote>
<p>在元素<code>float </code>之后脱离了文档流没有办法计算确切高度，这种情况我们称之为高度塌陷。解决高度塌陷的前提就是<code>能识</code>别并<code>包含</code>到浮动元素。<strong>而<code>BFC</code>就有这个特性</strong>，所以BFC也可以计算浮动元素的高度。新建BFC让浮动元素也参与计算 </p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        *&#123;<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;</span><br><span class="css">        <span class="hljs-selector-class">.par</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#fcc</span>;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">            <span class="hljs-comment">/*这里的overflow并不是为了超出则隐藏，而是为了创建一个BFC*/</span></span><br><span class="css">            <span class="hljs-comment">/* overflow: hidden; */</span></span><br><span class="css">            <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.child</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid <span class="hljs-number">#f66</span>;  </span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="css">            <span class="hljs-comment">/* clear: both; */</span></span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 网页的定位（大） 文档流正常，浮动，定位，flex，table --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;par&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>```  <br>- 三、每个元素的左边，要与包含盒子的左边相接触<br>- 四、BFC的区域不会与float box重叠  <br>```html<br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        *&#123;<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;</span><br><span class="css">        <span class="hljs-selector-class">.aside</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">150px</span>;</span><br><span class="css">            <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#ff6666</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.main</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">            <span class="hljs-attribute">background</span>: <span class="hljs-number">#ffcccc</span>;</span><br><span class="css">            <span class="hljs-comment">/* clear: left; */</span></span><br><span class="css">            <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 自适应两栏式布局 类似于flex：1；</span><br><span class="hljs-comment">    aside 和 main 处于同一BFC（body）下 </span><br><span class="hljs-comment">    BFC布局规则3 规则4 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;aside&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>```   <br>```html<br>/*BFC在三栏式布局中的应用*/<br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        *&#123;<span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;&#125;</span><br><span class="css">        <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>,<span class="hljs-selector-class">.center</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.left</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">background</span>: pink;</span><br><span class="css">            <span class="hljs-attribute">float</span>: left;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.right</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">background</span>: lightblue;</span><br><span class="css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">180px</span>;</span><br><span class="css">            <span class="hljs-attribute">float</span>: right;</span><br><span class="css">        &#125;</span><br><span class="css">        <span class="hljs-selector-class">.center</span>&#123;</span><br><span class="css">            <span class="hljs-attribute">background</span>: yellow;</span><br><span class="css">            <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 三栏式布局 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 页面的结构与呈现效果不一致？想一下 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>Left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>Right<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>Center<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br>```  <br><br>**注意：**  <br>&gt; 通过 overflow:hidden将元素转换为BFC，固然可以解决高度塌陷的问题，但是大范围的应用在布局上是肯定是行不通的，毕竟overflow会造成溢出隐藏的问题，特别是与JS交互的效果时。  <br><br>那有没有一个更好的高度检测方法呢？<br>答案是有的，就是我们经常用到的clearfix。  <br>```css<br>.clearfix:after&#123;<br>    content:&#x27;&#x27;;<br>    display:table;<br>    clear:both<br>&#125;<br>.clearfix&#123;<br>    *zoom:1;/* IE6,7不支持BFC，所以需要通过专有的CSS属性，触发hasLayout。*/<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/meierbao/p/6526247.html">关于zoom:1</a></p>
</li>
</ul>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/08/31/cssCenter/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="让div在屏幕上居中（水平居中+垂直居中）的方法总结" class="lazyload">
                    <h1>让div在屏幕上居中（水平居中+垂直居中）的方法总结</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年08月31日</a>
            <a><i class="nexmoefont icon-areachart"></i>235 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <ul>
<li><p>html代码如下：</p>
<pre><code class="html">    &lt;div class=&quot;book&quot;&gt;
            &lt;div class=&quot;front-cover&quot;&gt;
               
            &lt;/div&gt;
    &lt;/div&gt;
</code></pre>
</li>
<li><p>Css居中方法 （敲黑板）重点  </p>
<ul>
<li>首先将元素设置成为<code>绝对定位</code>，然后<code>距顶部和左各50%</code>，此时的元素还不是居中的，因此需要<code>通过一定的偏移</code>将其移到理想位置，两种方法的<code>主要思想</code>都是一样的，第一种通过margin-left和margin-top<code>移动元素自身宽高的一半</code>，另一种通过<code>css3</code>的属性transform的<code>translate方法</code>平移元素自身宽高的一半， 代码展示如下：<br>```css<br>body {<br>  color: #ffffff;<br>  background: #444444;<br>}</li>
</ul>
<p> .book {</p>
<pre><code> width: 300px;
 height: 300px;
 position: absolute;
 top: 50%;
 left: 50%;
 /* 第一种 */
 /* 兼容性 未使用css3, ie678 */
 /* margin-left: -150px; */
 /* margin-top: -150px; */
 /*第二种*/
 -webkit-transform: translate(-50%, -50%);
 transform: translate(-50%, -50%);
</code></pre>
<p> }<br> ```  </p>
<p> 两种方法第一种的兼容性更加的好一些，因为其中没有使用Css3的属性 对于ie678的兼容比较友好</p>
</li>
</ul>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/08/31/mixin/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="stylus之变量与mixin" class="lazyload">
                    <h1>stylus之变量与mixin</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年08月31日</a>
            <a><i class="nexmoefont icon-areachart"></i>683 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
        </div>

        <article>
            
                <h2 id="混合书写-Mixins"><a href="#混合书写-Mixins" class="headerlink" title="混合书写(Mixins)"></a>混合书写(Mixins)</h2><hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>在<code>stylus</code>中 可以将常用的样式像表达式中变量赋值一样保存给一个变量、如下：<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*进行变量的声明*/</span><br>bg_color = <span class="hljs-selector-id">#123456</span>;<br>box_size = <span class="hljs-number">100px</span>;<br><span class="hljs-comment">/* 使用 */</span><br><span class="hljs-selector-class">.box</span><br>    <span class="hljs-attribute">background-color</span> bg_color<br>    <span class="hljs-attribute">width</span> box_size<br>    <span class="hljs-attribute">height</span> box_size<br></code></pre></td></tr></table></figure>
  编译后：<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>   <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#123456</span>;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br> &#125;<br></code></pre></td></tr></table></figure></li>
<li>属性查找<br>Stylus有另外一个很酷的独特功能，不需要分配值给变量就可以定义引用属性。下面是个很好的例子，元素水平垂直居中对齐（典型的方法是使用百分比和margin负值），如下：<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#logo</span><br>    <span class="hljs-attribute">position</span>: absolute<br>    top: <span class="hljs-number">50%</span><br>    left: <span class="hljs-number">50%</span><br>    width: w = <span class="hljs-number">150px</span><br>    height: h = <span class="hljs-number">80px</span><br>    margin-left: <span class="hljs-built_in">-</span>(w / <span class="hljs-number">2</span>)<br>    margin-top: <span class="hljs-built_in">-</span>(h / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
在<code>stylus</code>中可以不使用这里的变量w和h, 而是简单地前置<code>@</code>字符在属性名前来访问该属性名对应的值：<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#logo</span><br>    <span class="hljs-attribute">position</span>: absolute<br>    top: <span class="hljs-number">50%</span><br>    left: <span class="hljs-number">50%</span><br>    width: <span class="hljs-number">150px</span><br>    height: <span class="hljs-number">80px</span><br>    margin-left: <span class="hljs-built_in">-</span>(@width / <span class="hljs-number">2</span>)<br>    margin-top: <span class="hljs-built_in">-</span>(@height / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<h3 id="混合书写"><a href="#混合书写" class="headerlink" title="混合书写"></a>混合书写</h3></li>
<li>混合书写和函数定义方法一致，但是应用却大相径庭。</li>
</ul>
<p>例如，在书写<code>Css3</code>样式时我们经常要进行兼容性处理，需要在属性前加上相应的前缀，下面有定义的border-radius(n)方法，其却作为一个mixin（如，作为状态调用，而非表达式）调用。   </p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">    bg_color = <span class="hljs-selector-id">#123456</span>;<br>    box_size = <span class="hljs-number">100px</span>;<br><br>    <span class="hljs-comment">/*定义mixin*/</span><br>    <span class="hljs-attribute">border-radius</span>(n)<br>        -webkit-<span class="hljs-attribute">border-radius</span> n<br>        -moz-<span class="hljs-attribute">border-radius</span> n<br>        -ms-<span class="hljs-attribute">border-radius</span> n<br>        -o-<span class="hljs-attribute">border-radius</span> n<br>        <span class="hljs-attribute">border-radius</span> n<br>    <span class="hljs-selector-class">.box</span><br>        <span class="hljs-attribute">background-color</span> bg_color<br>        <span class="hljs-attribute">width</span> box_size<br>        <span class="hljs-attribute">height</span> box_size<br>        <span class="hljs-attribute">border-radius</span>(<span class="hljs-number">5px</span>)<br>```  <br>进一步，我们可以利用arguments这个局部变量，传递可以包含多值的表达式,这样就可以給属性传递多个值。  <br>```css<br><span class="hljs-attribute">border-radius</span>()<br>        -webkit-<span class="hljs-attribute">border-radius</span> arguments<br>        -moz-<span class="hljs-attribute">border-radius</span> arguments<br>        -ms-<span class="hljs-attribute">border-radius</span> arguments<br>        -o-<span class="hljs-attribute">border-radius</span> arguments<br>        <span class="hljs-attribute">border-radius</span> arguments<br></code></pre></td></tr></table></figure>
<p><code>Stylus</code>支持通过使用{}字符包围表达式来插入值，其会变成标识符的一部分。例如，-webkit-{‘border’ + ‘-radius’}等同于<code>-webkit-border-radius</code>. </p>
<p>再进一步，在stylus中我们还可以对border-radius再做进一步的处理 类似与js中的函数封装 ，如下(这样对于任何需要做兼容性处理的属性 我们只需要调用两次mixin出入所需参数，大大的简化了一下琐碎代码工作):<br> <figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"> vendor(prop,args)<br>    -webkit-&#123;prop&#125; args<br>    -moz-&#123;prop&#125; args<br>    -ms-&#123;prop&#125; args<br>    -o-&#123;prop&#125; args<br>    &#123;prop&#125; args<br><br><span class="hljs-attribute">border-radius</span>(n)<br>    vendor(&#x27;<span class="hljs-attribute">border-radius</span>&#x27;,arguments)<br><span class="hljs-attribute">box-shadow</span>(n)<br>    vendor(&#x27;boa-shadow&#x27;,arguments)<br><span class="hljs-selector-class">.box</span><br>    <span class="hljs-attribute">background-color</span> bg_color<br>    <span class="hljs-attribute">width</span> box_size<br>    <span class="hljs-attribute">height</span> box_size<br>    <span class="hljs-attribute">border-radius</span>(<span class="hljs-number">5px</span>)<br></code></pre></td></tr></table></figure><br> 编译后：<br> <figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#123456</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  -ms-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  -o-<span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  -webkit-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>  -moz-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>  -ms-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>  -o-<span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">10px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2021/08/31/new/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="如何手动实现一个New操作" class="lazyload">
                    <h1>如何手动实现一个New操作</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2021年08月31日</a>
            <a><i class="nexmoefont icon-areachart"></i>842 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 3 分钟</a>
        </div>

        <article>
            
                <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><hr>
<p>在所有的前端面试中常常喜欢考面试者如何手写一个new操作符，作为在准备秋招的大三党，我也要考虑这些。<br>那么我们先看看new操作符都干了什么事情，有哪些操作？通过下面的代码来进行思考：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 新建一个类（构造函数）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Otaku</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-comment">// 自身的属性</span><br>    <span class="hljs-built_in">this</span>.habit = <span class="hljs-string">&#x27;pk&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 给类的原型上添加属性和方法</span><br>Otaku.prototype.strength = <span class="hljs-number">60</span>;<br>Otaku.prototype.sayYourName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;I am &#x27;</span> + <span class="hljs-built_in">this</span>.name);<br>&#125;<br><span class="hljs-comment">// 实例化一个person对象</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Otaku(<span class="hljs-string">&#x27;乔峰&#x27;</span>,<span class="hljs-number">5000</span>);<br>person.sayYourName();<br><span class="hljs-built_in">console</span>.log(person);<span class="hljs-comment">//打印出构造出来的实例</span><br><span class="hljs-string">``</span><span class="hljs-string">`    </span><br><span class="hljs-string">![控制台打印结果](http://p9utic4op.bkt.clouddn.com/new.png)   </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">## 解析  </span><br><span class="hljs-string"></span><br><span class="hljs-string">从控制台打印出来的结果我们可以看出new操作符大概做了一下几件事情：  </span><br><span class="hljs-string"></span><br><span class="hljs-string"> 1. 返回（产生）了一个新的对象  </span><br><span class="hljs-string"> 2. 访问到了类Otaku构造函数里的属性  </span><br><span class="hljs-string"> 3. 访问到Otaku原型上的属性和方法  并且设置了this的指向（指向新生成的实例对象）</span><br><span class="hljs-string"> </span><br><span class="hljs-string">通过上面的分析展示，可以知道new团伙里面一定有Object的参与，不然对象的产生就有点说不清了。 先来边写写：  </span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-comment">// 需要返回一个对象 借助函数来实现new操作 </span><br><span class="hljs-comment">// 传入需要的参数： 类 + 属性</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Otaku(<span class="hljs-string">&#x27;乔峰&#x27;</span>,<span class="hljs-number">5000</span>);<br><span class="hljs-keyword">const</span> person1 = objectFactory(Otaku, <span class="hljs-string">&#x27;鸠摩智&#x27;</span>, <span class="hljs-number">5000</span>);<br><br><span class="hljs-comment">// 开始来实现objectFactory 方法 </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params">obj, name, age</span>) </span>&#123;&#125;<br><span class="hljs-comment">// 这种方法将自身写死了 如此他只能构造以obj为原型，并且只有name 和 age 属性的 obj</span><br><span class="hljs-comment">// 在js中 函数因为arguments 使得函数参数的写法异常灵活，在函数内部可以通过arguments来获得函数的参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arguements); <span class="hljs-comment">//&#123; &#x27;0&#x27;: [Function: Otaku], &#x27;1&#x27;: &#x27;鸠摩智&#x27;, &#x27;2&#x27;: 5000 &#125;</span><br>     <span class="hljs-comment">// 通过arguments类数组打印出的结果，我们可以看到其中包含了构造函数以及我们调用objectfactory时传入的其他参数</span><br>    <span class="hljs-comment">// 接下来就是要想如何得到其中这个构造函数和其他的参数</span><br>    <span class="hljs-comment">// 由于arguments是类数组，没有直接的方法可以供其使用，我们可以有以下两种方法:</span><br>    <span class="hljs-comment">// 1. Array.from(arguments).shift(); //转换成数组 使用数组的方法shift将第一项弹出</span><br>    <span class="hljs-comment">// 2.[].shift().call(arguments); // 通过call() 让arguments能够借用shift方法</span><br>    <span class="hljs-keyword">const</span> Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-comment">// 新建一个空对象 纯洁无邪</span><br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    <span class="hljs-comment">// 接下来的想法 给obj这个新生对象的原型指向它的构造函数的原型  </span><br>    <span class="hljs-comment">// 给构造函数传入属性，注意：构造函数的this属性</span><br>    <span class="hljs-comment">// 参数传进Constructor对obj的属性赋值，this要指向obj对象</span><br>    <span class="hljs-comment">// 在Coustructor内部手动指定函数执行时的this 使用call、apply实现</span><br>    Constructor.call(obj,...args);<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string">- 上面的代码注释太多，剔除注释以后的代码：</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>);<br>        <span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>        obj.__proto__ = Conctructor.prototype;<br>        Constructor.call(obj,...arguments);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br><span class="hljs-string">``</span><span class="hljs-string">`    </span><br><span class="hljs-string">- 还有另外一种操作： </span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>js<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Obj,...args</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(Obj.prototype);<span class="hljs-comment">//使用指定的原型对象及其属性去创建一个新的对象</span><br>  Obj.apply(obj,args); <span class="hljs-comment">// 绑定 this 到obj, 设置 obj 的属性</span><br>  <span class="hljs-keyword">return</span> obj; <span class="hljs-comment">// 返回实例</span><br>&#125;<br></code></pre></td></tr></table></figure>


            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/11/18/reactHooks/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="React Hook学习" class="lazyload">
                    <h1>React Hook学习</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年11月18日</a>
            <a><i class="nexmoefont icon-areachart"></i>2.6k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 12 分钟</a>
        </div>

        <article>
            
                <p>  Hooks 在React <strong>16.8</strong> 以上的版本中才可以使用<br>  <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a></p>
<h2 id="Hook-定义"><a href="#Hook-定义" class="headerlink" title="Hook 定义"></a>Hook 定义</h2><blockquote>
<p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的<code>函数</code>。  </p>
</blockquote>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/10/26/reactRefs/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="React中的Refs" class="lazyload">
                    <h1>React中的Refs</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年10月26日</a>
            <a><i class="nexmoefont icon-areachart"></i>912 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p><strong>官方说明</strong>： <code>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素</code>。</p>
<p>在React开发中、想要操作元素的状态一般是修改State、或者是修改传入的props。但是有时候一些效果不能通过如此操作实现，例如开发中常常碰到的： </p>
<ul>
<li>输入框的焦点获取、比如打开登录界面登录框自动获取焦点 </li>
<li>动态的根据一个元素的大小/距离 计算另外一个元素的大小 </li>
</ul>
<h2 id="使用-Ref"><a href="#使用-Ref" class="headerlink" title="使用 Ref"></a>使用 Ref</h2><p>目前的React版本（16.11.0）中 <code>Refs</code> 的用法如下： </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React form <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-comment">// 创建</span><br>    <span class="hljs-built_in">this</span>.myRef = React.createRef();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 传入</span><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.myRef&#125;</span> /&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于节点的访问: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> node = <span class="hljs-built_in">this</span>.myRef.current;<br></code></pre></td></tr></table></figure>

<p>说明： </p>
<ul>
<li>1.通过调用 React.createRef 创建了一个 React ref 并将 DOM节点的引用current赋值给 this.myRef 变量。 </li>
<li><ol start="2">
<li>指定 ref 为 JSX 属性，将this.myRef 传入; ref 和 key 一样不属于 props属性，二者都会被 React 特殊处理和维护。</li>
</ol>
</li>
<li><ol start="3">
<li>ref 挂载以后，ref.current 指向 ref 所在节点</li>
</ol>
</li>
</ul>
<p>如果之前用过 React，你可能了解之前的 ref 可以通过 this.refs.inputRef 来访问 DOM 节点、如下所示，这个 ref 是字符串类型的，在使用上来说似乎更加方便。现在官方版本不建议再使用它，因为 string 类型的 refs 存在问题。它属于<code>过时</code> API 并可能会在未来的版本被移除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React form <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.refs.inputRef.focus();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 还能用 但不建议</span><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;inputRef&quot;</span> /&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Ref的值"><a href="#Ref的值" class="headerlink" title="Ref的值"></a>Ref的值</h2><p>官方文档中有说明，ref 的值根据节点的类型不同而有所不同：</p>
<ul>
<li>当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref <strong>对象</strong> 接收底层 DOM 元素作为其 current 属性。可以访问元素的宽高等属性、input框还可以调用focus方法实现自动聚焦</li>
<li>当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。即可以通过 current <code>调用组件中的方法 </code></li>
</ul>
<p>不能在函数组件上使用 ref 属性，因为他们没有实例。</p>
<h2 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h2><p>更加精细的控制 refs 的传递, 可以达到类似 props 的传递效果，在需要的地方传入inputRef </p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 官方 Demo</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;props.inputRef&#125;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomTextInput</span></span></span><br><span class="hljs-tag"><span class="xml">        <span class="hljs-attr">inputRef</span>=<span class="hljs-string">&#123;el</span> =&gt;</span> this.inputElement = el&#125;</span><br><span class="xml">      /&gt;</span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>官方说明</strong>： </p>
<p>如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p>
<h2 id="Refs-转发"><a href="#Refs-转发" class="headerlink" title="Refs 转发"></a>Refs 转发</h2><h2 id="ref-Hook"><a href="#ref-Hook" class="headerlink" title="ref Hook"></a>ref Hook</h2><p>useRef() 是 React 提供的在 Hooks 中获取 DOM 元素的方法。<br>使用方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useRef&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RefDemo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> inputEl = useRef(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">const</span> onButtonClick=<span class="hljs-function">()=&gt;</span>&#123; <br>        inputEl.current.value=<span class="hljs-string">&quot;Hello, Ref&quot;</span>;<br>        <span class="hljs-built_in">console</span>.log(inputEl); <span class="hljs-comment">//输出获取到的DOM节点</span><br>    &#125;;<br>    <span class="hljs-keyword">return</span> (<br>        <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">            &#123;/*保存input的ref到inputEl */&#125;</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;inputEl&#125;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span> = <span class="hljs-string">&#123;onButtonClick&#125;</span>&gt;</span>展示<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> RefDemo;<br></code></pre></td></tr></table></figure>


<!-- TODO -->

<p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">官方文档</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2019/08/05/Array/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="数组" class="lazyload">
                    <h1>数组</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2019年08月05日</a>
            <a><i class="nexmoefont icon-areachart"></i>1.4k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 6 分钟</a>
        </div>

        <article>
            
                <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><blockquote>
<p>一个存储元素的线性集合， 元素可以通过索引（通常为数字）来任意存取。  </p>
</blockquote>
<p>数字索引在内部被转换为字符串类型、这是因为在javaScript中对象的属性名必须是字符串。而数组只是一种特殊的对象</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul>
<li>通过<code>构造函数</code> <figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;!-- 传入一组元素进行数组初始化 --&gt;<br><span class="hljs-keyword">var</span> arr = New <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>print(arr.length); <span class="hljs-comment">// 5</span><br>&lt;!-- 只传一个元素，声明数组的初始化长度, 其中每个元素初始化为 <span class="hljs-literal">undefined</span> --&gt;<br><span class="hljs-keyword">var</span> arr1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>);<br>print(arr1.length); <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/07/30/type/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="JS 基本数据类型和引用类型" class="lazyload">
                    <h1>JS 基本数据类型和引用类型</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年07月30日</a>
            <a><i class="nexmoefont icon-areachart"></i>290 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 1 分钟</a>
        </div>

        <article>
            
                <h2 id="Js-基本数据类型"><a href="#Js-基本数据类型" class="headerlink" title="Js 基本数据类型"></a>Js 基本数据类型</h2><p>js基本数据类型包括：<code>undefined</code>, <code>null</code>, <code>number</code>, <code>boolean</code>, <code>string</code>, <code>symbol</code>, <code>bigInt（新增）</code>。基本数据类型是按值访问的，就是说我们可以操作保存在变量中的实际的值  </p>
<h3 id="1-基本数据类型的值是不可改变的"><a href="#1-基本数据类型的值是不可改变的" class="headerlink" title="1.基本数据类型的值是不可改变的"></a>1.基本数据类型的值是不可改变的</h3><p> 任何方法都无法改变一个基本类型的值是不可改变的，比如一个字符串：  </p>
 <figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;change&quot;</span>;<br>name.substr();<span class="hljs-comment">//hang</span><br><span class="hljs-built_in">console</span>.log(name);<span class="hljs-comment">//change</span><br><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;hello&quot;</span>;<br>s.toUpperCase()<span class="hljs-comment">//HELLO;</span><br><span class="hljs-built_in">console</span>.log(s)<span class="hljs-comment">//hello  </span><br><br></code></pre></td></tr></table></figure>

<p> 通过这两个例子， 我们原来发现定义的变量 name 的值始终没有发生改变，而调用 substr() 和 toUpperCase() 方法后返回的是一个新的字符串，跟原先定义的变量 name 并没有关系  </p>
<h3 id="按值访问"><a href="#按值访问" class="headerlink" title="按值访问"></a>按值访问</h3><p> 按值进行访问，操作的是保存在变量中实际的值 </p>
<h3 id="不可添加方法属性"><a href="#不可添加方法属性" class="headerlink" title="不可添加方法属性"></a>不可添加方法属性</h3><h3 id="基础类型的比较是值的比较"><a href="#基础类型的比较是值的比较" class="headerlink" title="基础类型的比较是值的比较"></a>基础类型的比较是值的比较</h3><h3 id="基础类型存放在栈区-变量标识符-变量值"><a href="#基础类型存放在栈区-变量标识符-变量值" class="headerlink" title="基础类型存放在栈区 变量标识符 + 变量值"></a>基础类型存放在栈区 变量标识符 + 变量值</h3><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="同时保存在栈区和堆区中"><a href="#同时保存在栈区和堆区中" class="headerlink" title="同时保存在栈区和堆区中"></a>同时保存在栈区和堆区中</h3><p>栈区保存变量标识符和指向堆区的方法</p>
<h2 id="基本包装类型（包装对象）"><a href="#基本包装类型（包装对象）" class="headerlink" title="基本包装类型（包装对象）"></a>基本包装类型（包装对象）</h2>
            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/07/20/Better/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 52.77777777777778%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/20/20/05/mountains-6561191__480.jpg" data-sizes="auto" alt="性能优化之浏览器篇" class="lazyload">
                    <h1>性能优化之浏览器篇</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年07月20日</a>
            <a><i class="nexmoefont icon-areachart"></i>995 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 4 分钟</a>
        </div>

        <article>
            
                <h2 id="把-Css-放在head-中加载"><a href="#把-Css-放在head-中加载" class="headerlink" title="把 Css 放在head 中加载"></a>把 Css 放在head 中加载</h2><blockquote>
<p>在浏览器解析完head 部分后、让浏览器知道需要引入哪些css文件，开始并行的去下载css资源，一边下载Css文件一边解析Html, 能够使页面更早的开始渲染  </p>
</blockquote>
<ul>
<li>让页面更早的开始渲染、避免闪屏  （DOM 结构先加载出来，css慢了一拍 页面重新渲染）</li>
<li>最好能包含关键渲染路径的样式、首页的样式应该尽快的完成加载、提高用户体验  </li>
</ul>
<h2 id="JS放在-body-标签结束前加载"><a href="#JS放在-body-标签结束前加载" class="headerlink" title="JS放在 body 标签结束前加载"></a>JS放在 body 标签结束前加载</h2><blockquote>
<p>js 资源的加载会阻塞 HTML 的解析 和 Css的渲染</p>
</blockquote>
<h2 id="不使用CSS-表达式"><a href="#不使用CSS-表达式" class="headerlink" title="不使用CSS 表达式"></a>不使用CSS 表达式</h2><p> 在css属性后使用 expression() 连接一段JavaScript表达式，css属性的值是JavaScript表达式的结果。</p>
 <figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">expression</span>((new <span class="hljs-built_in">Date</span>()).<span class="hljs-built_in">getHours</span>()%<span class="hljs-number">2</span>?<span class="hljs-string">&quot;#FFFFFF&quot;</span>: <span class="hljs-string">&quot;#000000&quot;</span> );<br></code></pre></td></tr></table></figure>

<blockquote>
<p>看似强大， 实际性能开销很大，可能导致页面卡顿  </p>
</blockquote>
<p>  表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次。给 CSS 表达式增加一个计数器可以跟踪表达式的计算频率。在页面中随便移动鼠标都可以轻松达到 10000 次以上的计算量。<br>  <del>calc() 性能待验证</del></p>
<h2 id="移除无匹配的样式"><a href="#移除无匹配的样式" class="headerlink" title="移除无匹配的样式"></a>移除无匹配的样式</h2><p>移除无匹配的样式，有两个好处：  </p>
<ul>
<li><p>删除无用的样式后可以缩减样式文件的体积，加快资源下载速度；</p>
</li>
<li><p>对于浏览器而言，所有的样式规则的都会被解析后索引起来，即使是当前页面无匹配的规则。移除无匹配的规则，减少索引项，加快浏览器查找速度；</p>
</li>
</ul>
<h2 id="用外链的方式引入css-和-js"><a href="#用外链的方式引入css-和-js" class="headerlink" title="用外链的方式引入css 和 js"></a>用外链的方式引入css 和 js</h2><ul>
<li>通过使用外链可以减少html 文件的体积  </li>
<li>作为外链文件、Css/Js 可以作为静态资源、通过合理的利用浏览器的缓存对需要的文件进行缓存； 在第二次访问时可以加快页面的加载速度  </li>
</ul>
<h2 id="不要重复加载JS"><a href="#不要重复加载JS" class="headerlink" title="不要重复加载JS"></a>不要重复加载JS</h2><ul>
<li>在IE中，例如在加载一个jquery以后再加载一个jquery，仍然是算作两个不同的请求，不能发挥缓存的优势  </li>
<li>重复加载js意味着更长的JS执行时间  </li>
</ul>
<h2 id="用-Get-方式发起-Ajax-请求"><a href="#用-Get-方式发起-Ajax-请求" class="headerlink" title="用 Get 方式发起 Ajax 请求"></a>用 Get 方式发起 Ajax 请求</h2><ul>
<li>Get 方式可以缓存  </li>
<li>如果是获取信息 Get 更加语义化  </li>
</ul>
<p>  如果是提交数据 使用Post 更加语义化  </p>
<h2 id="组件延迟加载"><a href="#组件延迟加载" class="headerlink" title="组件延迟加载"></a>组件延迟加载</h2><blockquote>
<p>规划页面中引用的姿态资源加载顺序、优先级的能力</p>
</blockquote>
<ul>
<li><p>保障关键页面资源的优先加载: 浏览器的并发数限制  </p>
<blockquote>
<p>在同一个域名下面，一般现代浏览器的并发数为6 </p>
</blockquote>
</li>
<li><p>按需加载 Lazyload 典型： 电商网站  </p>
<blockquote>
<p>在图片比较多的电商网站中，lazyload 十分实用 data-src -&gt; src  </p>
</blockquote>
</li>
</ul>
<h2 id="避免在页面中使用iFrame"><a href="#避免在页面中使用iFrame" class="headerlink" title="避免在页面中使用iFrame"></a>避免在页面中使用iFrame</h2><ul>
<li>会阻塞父文档的 <code>onload</code> 事件  </li>
<li>即使是空白iFrame 也比较耗时</li>
</ul>
<h2 id="减少COOKIE体积"><a href="#减少COOKIE体积" class="headerlink" title="减少COOKIE体积"></a>减少COOKIE体积</h2><ul>
<li>COOKIE每次请求都会全都带上<br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004556040">COOKIE了解更多</a>   <blockquote>
<p>每次请求跟主文档相关的信息，所有的cookie都会带上  </p>
</blockquote>
</li>
</ul>
<h2 id="减少-JS-中的-DOM-访问"><a href="#减少-JS-中的-DOM-访问" class="headerlink" title="减少 JS 中的 DOM 访问"></a>减少 JS 中的 DOM 访问</h2><blockquote>
<p>JS中对DOM 的访问是不可避免的, 但可以进行一下优化  </p>
</blockquote>
<ul>
<li>对于查找到的元素， 先将其缓存在变量中  </li>
<li>节点增加时合理利用 <code>DocumentFragment</code>  </li>
<li>不要用JS 去频繁修改样式</li>
</ul>
<h2 id="使用常见的图片优化手段"><a href="#使用常见的图片优化手段" class="headerlink" title="使用常见的图片优化手段"></a>使用常见的图片优化手段</h2><blockquote>
<p>相比代码， 图片的体积很大  </p>
</blockquote>
<h2 id="不要在HTML中缩放图片"><a href="#不要在HTML中缩放图片" class="headerlink" title="不要在HTML中缩放图片"></a>不要在HTML中缩放图片</h2><p>在实际中使用什么尺寸的图片就提供多大尺寸的图片  </p>
<ul>
<li>徒增渲染开销， 提供适当尺寸即可  <h2 id="不要把图片的src置空"><a href="#不要把图片的src置空" class="headerlink" title="不要把图片的src置空"></a>不要把图片的src置空</h2></li>
<li>在主流浏览器中 IE、Chrome、FireFox 都会引发指向当前主文档的额外请求</li>
</ul>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a target="_blank" rel="noopener" href="http://www.alloyteam.com/2012/10/high-performance-css/">高性能 CSS</a></p>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2018/07/18/regExp/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: NaN%;"> 
                    <img data-src="https://cdn.pixabay.com/photo/2021/08/19/16/31/flowers-6558487__480.jpg" data-sizes="auto" alt="RegExp 正则表达式" class="lazyload">
                    <h1>RegExp 正则表达式</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta nexmoe-rainbow">
            <a><i class="nexmoefont icon-calendar-fill"></i>2018年07月18日</a>
            <a><i class="nexmoefont icon-areachart"></i>577 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 2 分钟</a>
        </div>

        <article>
            
                <h1 id="RegRxp-正则表达式"><a href="#RegRxp-正则表达式" class="headerlink" title="RegRxp(正则表达式)"></a>RegRxp(正则表达式)</h1><blockquote>
<p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等,简化对字符串的操作  </p>
</blockquote>
            
        </article>
    </div>
    
</section>

    <nav class="nexmoe-page-nav">
        <span class="page-number current">1</span><a class="page-number" href="/categories/%E5%89%8D%E7%AB%AF/page/2/">2</a><a class="extend next" rel="next" href="/categories/%E5%89%8D%E7%AB%AF/page/2/"><i class="nexmoefont icon-right"></i></a>
    </nav>
  
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="回到顶部" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js?v=1"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

 

<script async src="/js/app.js?v=1630501965046"></script>

<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js"></script>
<script>
	$(".justified-gallery").justifiedGallery({
		rowHeight: 160,
		margins: 10,
	});
</script>


    





    <!-- baidu Analytics -->
<script>
    var _hmt = _hmt || [];
    (function() {var hm = document.createElement('script');
    hm.src = 'https://hm.baidu.com/hm.js?1b3ede68905f0bbb58c39b0e279d6246';
    var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

</body>

</html>
